<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>🧠 Hemi-Lab Ultra</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="binaural_engine.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: radial-gradient(
          circle at 50% 50%,
          #0a0a2e 0%,
          #000000 100%
        );
        color: #ffffff;
        font-family: "Courier New", monospace;
        min-height: 100vh;
        overflow-x: hidden;
      }
      body.light-mode {
        background: radial-gradient(circle at 50% 50%, #ffffff 0%, #dddddd 100%);
        color: #000000;
      }

      body.light-mode .control-panel {
        background: rgba(0, 0, 0, 0.05);
        border-color: rgba(0, 0, 0, 0.2);
      }

      body.light-mode .visualization-area {
        background: radial-gradient(circle at center, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.2) 100%);
        border-color: rgba(0, 0, 0, 0.3);
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
        padding: 20px 0;
      }

      .header h1 {
        font-size: 2.5rem;
        background: linear-gradient(45deg, #00ff88, #0099ff, #ff0088);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 10px;
        text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
      }

      .header p {
        opacity: 0.8;
        font-size: 1.1rem;
        letter-spacing: 2px;
      }

      .main-interface {
        display: grid;
        grid-template-columns: 1fr 400px;
        gap: 30px;
        margin-bottom: 40px;
      }

      .control-panel {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 15px;
        padding: 25px;
        backdrop-filter: blur(10px);
      }

      .visualization-area {
        position: relative;
        overflow: hidden;
        background: radial-gradient(
          circle at center,
          rgba(0, 0, 0, 0.4) 0%,
          rgba(0, 0, 0, 0.2) 100%
        );
        border: 1px solid rgba(0, 153, 255, 0.3);
        border-radius: 15px;
        padding: 25px;
        min-height: 500px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .visualization-area::before {
        content: "";
        position: absolute;
        inset: 0;
        background-image:
          radial-gradient(#00ff88 1px, transparent 1px),
          radial-gradient(#0099ff 1px, transparent 1px),
          radial-gradient(#ff0088 1px, transparent 1px);
        background-size:
          3px 3px,
          4px 4px,
          5px 5px;
        background-position:
          0 0,
          40px 60px,
          20px 40px;
        animation: starScroll 60s linear infinite;
        opacity: 0.25;
        pointer-events: none;
      }

      @keyframes starScroll {
        from {
          transform: translateY(0);
        }
        to {
          transform: translateY(-1000px);
        }
      }

      .focus-selector {
        margin-bottom: 25px;
      }

      .focus-selector h3 {
        color: #00ff88;
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .focus-levels {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .focus-btn {
        background: rgba(0, 255, 136, 0.1);
        border: 1px solid rgba(0, 255, 136, 0.3);
        color: #ffffff;
        padding: 12px 8px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        text-align: center;
      }

      .focus-btn:hover {
        background: rgba(0, 255, 136, 0.2);
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
      }

      .focus-btn.active {
        background: rgba(0, 255, 136, 0.3);
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
      }

      .audio-controls {
        margin-bottom: 25px;
      }

      .audio-controls h3 {
        color: #0099ff;
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-group label {
        display: block;
        margin-bottom: 5px;
        color: #cccccc;
        font-size: 0.9rem;
      }

      .slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.1);
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #00ff88;
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
      }

      .mode528 #mode528Slider {
        display: none;
      }
      .mode528:hover #mode528Slider {
        display: block;
      }

      .composer-desc {
        font-size: 0.9rem;
        opacity: 0.8;
        margin-bottom: 10px;
      }

      .help-icon {
        margin-left: 4px;
        cursor: help;
      }

      .help-tooltip {
        position: fixed;
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        pointer-events: none;
        z-index: 2000;
        display: none;
      }

      .session-controls {
        display: flex;
        gap: 15px;
        margin-bottom: 25px;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-family: inherit;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        flex: 1;
      }

      .btn-primary {
        background: linear-gradient(45deg, #00ff88, #0099ff);
        color: #000000;
        font-weight: bold;
      }

      .btn-primary:hover {
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        transform: translateY(-2px);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .bookmark-btn.active {
        background: linear-gradient(45deg, #ff0088, #fff200);
        color: #000;
        box-shadow: 0 0 20px rgba(255, 0, 136, 0.6);
      }

      .rebal-container {
        position: relative;
        width: 300px;
        height: 300px;
        overflow: visible;
      }

      .rebal-orb {
        position: absolute;
        width: 150%;
        height: 150%;
        top: -25%;
        left: -25%;
        border-radius: 50%;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(0, 255, 136, 0.7),
          rgba(0, 153, 255, 0.4),
          rgba(255, 0, 136, 0.3)
        );
        box-shadow:
          0 0 60px rgba(0, 255, 136, 0.5),
          inset 0 0 60px rgba(0, 153, 255, 0.3);
        filter: drop-shadow(0 0 15px rgba(255, 0, 136, 0.4));
        overflow: hidden;
        will-change: transform, opacity;
        transform: translateZ(0);
        backface-visibility: hidden;
      }

      .rebal-orb::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: conic-gradient(
          transparent,
          rgba(0, 255, 136, 0.1),
          transparent
        );
      }

      .rebal-orb.animate {
        animation: rebalPulse 4s ease-in-out infinite;
      }

      .rebal-orb.animate::before {
        animation: rebalRotate 8s linear infinite;
      }

      @keyframes rebalPulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.1);
          opacity: 1;
        }
      }

      @keyframes rebalRotate {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .breath-coach {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      .breath-coach.active {
        opacity: 1;
      }

      .breath-text {
        font-size: 1.2rem;
        margin-bottom: 10px;
        color: #00ff88;
      }

      .breath-bar {
        width: 200px;
        height: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        overflow: hidden;
      }

      .breath-progress {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #00ff88, #0099ff);
        transition: width linear;
      }

      .equalizer-container {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 40px;
        pointer-events: none;
      }

      canvas.equalizer {
        width: 300px;
        height: 100px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 8px;
      }

      .session-info {
        margin-bottom: 25px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        border-left: 4px solid #00ff88;
      }

      .session-progress {
        margin-top: 10px;
      }

      .progress-bar {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-fill {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #0099ff, #ff0088);
        transition: width 0.3s linear;
      }

      .journal-section {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 0, 136, 0.3);
        border-radius: 15px;
        padding: 25px;
        margin-top: 30px;
      }

      .journal-section h3 {
        color: #ff0088;
        margin-bottom: 20px;
        font-size: 1.3rem;
      }

      .bookmark-section {
        margin-top: 20px;
      }

      .bookmark-slots {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        gap: 8px;
        margin-top: 10px;
      }

      .journal-form {
        display: grid;
        gap: 15px;
      }

      .form-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .form-group label {
        color: #cccccc;
        font-size: 0.9rem;
      }

      .form-group input,
      .form-group select,
      .form-group textarea {
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.3);
        color: #ffffff;
        font-family: inherit;
        font-size: 0.9rem;
      }

      .form-group textarea {
        resize: vertical;
        min-height: 100px;
      }

      .stats-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .stat-card {
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #00ff88;
      }

      .stat-label {
        font-size: 0.8rem;
        opacity: 0.7;
        margin-top: 5px;
      }

      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-offline {
        background: #666;
      }
      .status-active {
        background: #00ff88;
        animation: pulse 2s infinite;
      }
      .status-contact {
        background: #ff0088;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .analysis-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: 20px;
      }

      .analysis-content {
        background: #111;
        padding: 20px;
        border-radius: 8px;
        max-width: 600px;
        width: 100%;
        max-height: 80vh;
        .composer-section {
          margin-top: 15px;
        }
        .composer-section input {
          width: 60px;
          margin-right: 5px;
        }
        overflow-y: auto;
      }

      .github-link {
        display: inline-block;
        margin-top: 10px;
        color: #00ff88;
        text-decoration: none;
      }

      .github-link:hover {
        text-decoration: underline;
      }

      .theme-switch {
        margin-top: 10px;
        display: inline-block;
      }
      .instructions {
        margin-bottom: 20px;
        text-align: center;
      }

      .instructions details {
        display: inline-block;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 8px;
        padding: 10px;
        text-align: left;
        max-width: 600px;
      }

      .instructions summary {
        cursor: pointer;
        font-weight: bold;
        color: #00ff88;
        outline: none;
      }

      @media (max-width: 768px) {
        .main-interface {
          grid-template-columns: 1fr;
        }

        .header h1 {
          font-size: 1.8rem;
        }

        .rebal-container {
          width: 250px;
          height: 250px;
          overflow: visible;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header class="header">
        <h1>🧠 Hemi-Lab Ultra</h1>
        <p>Consciousness Exploration • Science • Spirit • Precision</p>
        <a
          href="https://github.com/meistro57/Hemi-Lab_Ultra"
          target="_blank"
          class="github-link"
          >View on GitHub</a
        <label class="theme-switch">
          <input type="checkbox" id="themeToggle" /> Light Mode
        </label>
      </header>

      <div class="instructions">
        <details>
          <summary>📜 Instructions</summary>
          <p>🧠 Welcome to Hemi-Lab Gateway Terminal</p>
          <p>
            Your consciousness exploration platform is ready. Features
            available:
          </p>
          <ul>
            <li>Binaural Beat Engine - Create custom frequency entrainment</li>
            <li>Focus Level Navigator - Monroe Institute inspired states</li>
            <li>REBAL Energy Shield - Resonant protection visualization</li>
            <li>Breath Coach - Synchronized breathing guidance</li>
            <li>Session Journal - Track your journey and insights</li>
            <li>Pattern Analysis - Discover your optimal practice times</li>
            <li>Affirmation Layer - Spoken positive cues</li>
          </ul>
          <p>
            🚀 Select a Focus Level and click "Begin Session" to start your
            exploration.
          </p>
          <p>For best results:</p>
          <ul>
            <li>Use quality headphones</li>
            <li>Find a quiet, comfortable space</li>
            <li>Set an intention before beginning</li>
            <li>Journal your experiences after each session</li>
          </ul>
          <p>
            The deeper states (Focus 15, 21, 23+) may produce profound
            experiences. Trust the process and document everything.
          </p>
        </details>
      </div>

      <div class="main-interface">
        <div class="visualization-area">
          <div class="rebal-container">
            <div class="rebal-orb" id="rebalOrb"></div>
          </div>
          <div class="breath-coach" id="breathCoach">
            <div class="breath-text" id="breathText">Breathe In</div>
          <div class="breath-bar">
            <div class="breath-progress" id="breathProgress"></div>
          </div>
          <div class="equalizer-container">
            <canvas id="leftEQ" class="equalizer" width="300" height="100"></canvas>
            <canvas id="rightEQ" class="equalizer" width="300" height="100"></canvas>
          </div>
        </div>
      </div>

      <div class="control-panel">
          <div class="focus-selector">
            <h3>🌌 Focus Level Navigator</h3>
            <div class="focus-levels">
              <button class="focus-btn" data-focus="10">
                Focus 10<br /><small>Body Asleep</small>
              </button>
              <button class="focus-btn" data-focus="12">
                Focus 12<br /><small>Expanded</small>
              </button>
              <button class="focus-btn" data-focus="15">
                Focus 15<br /><small>No-Time</small>
              </button>
              <button class="focus-btn" data-focus="21">
                Focus 21<br /><small>Threshold</small>
              </button>
              <button class="focus-btn" data-focus="23">
                Focus 23+<br /><small>Contact</small>
              </button>
              <button class="focus-btn" data-focus="custom">
                Custom<br /><small>Compose</small>
              </button>
            </div>
            <div class="control-group" style="margin-top: 10px">
              <label>Focus Slider: <span id="focusSliderValue">10</span></label>
              <input
                type="range"
                class="slider"
                id="focusSlider"
                min="10"
                max="23"
                value="10"
              />
            </div>
          </div>

          <div class="audio-controls">
            <h3>🔊 Audio Engine</h3>
            <div class="control-group">
              <label
                >Base Frequency (Hz): <span id="baseFreqValue">100</span></label
              >
                <input
                  type="range"
                  class="slider"
                  id="baseFreq"
                  min="40"
                  max="1000"
                  value="100"
                />
            </div>
            <div class="control-group">
              <label
                >Beat Frequency (Hz): <span id="beatFreqValue">8</span></label
              >
              <input
                type="range"
                class="slider"
                id="beatFreq"
                min="0.5"
                max="40"
                value="8"
                step="0.5"
              />
            </div>
            <div class="control-group">
              <label>
                Waveform:
                <select id="waveType">
                  <option value="sine">Sine</option>
                  <option value="square">Square</option>
                  <option value="sawtooth">Sawtooth</option>
                  <option value="triangle">Triangle</option>
                </select>
              </label>
            </div>
            <div class="control-group">
              <label>Volume: <span id="volumeValue">50</span>%</label>
              <input
                type="range"
                class="slider"
                id="volume"
                min="0"
                max="100"
                value="50"
              />
            </div>
            <div class="control-group">
              <label
                >Phase Shift (°): <span id="phaseShiftValue">0</span></label
              >
              <input
                type="range"
                class="slider"
                id="phaseShift"
                min="0"
                max="360"
                value="0"
              />
            </div>
            <div class="control-group">
              <label
                >Session Duration (min):
                <span id="durationValue">15</span></label
              >
                <input
                  type="range"
                  class="slider"
                  id="sessionDuration"
                  min="1"
                  max="60"
                  value="15"
                />
              </div>
              <div class="control-group mode528">
                <label>
                  <input type="checkbox" id="mode528" /> 528 Mode
                </label>
                <input
                  type="range"
                  class="slider"
                  id="mode528Slider"
                  min="520"
                  max="536"
                  value="528"
                />
              </div>
              <div class="control-group">
                <label>
                  <input type="checkbox" id="isochronicMode" /> Isochronic Pulse
                  Layer
                </label>
              </div>
              <div class="control-group">
                <label>
                  <input type="checkbox" id="deepBassMode" /> Deep Bass Beats
                </label>
              </div>
            <div class="control-group">
              <label>
                <input type="checkbox" id="driftMode" /> Drift Mode
              </label>
            </div>
            <div class="control-group">
              <label>
                <input type="checkbox" id="entropyMode" /> Entropy Drift
              </label>
            </div>
            <div class="control-group">
              <label>
                <input type="checkbox" id="rebalMode" checked /> REBAL Energy
                Shield
              </label>
            </div>
            <div class="control-group">
              <label>
                <input type="checkbox" id="breathCoachMode" /> Breath Coach
              </label>
            </div>
            <div
              class="control-group"
              id="breathPatternGroup"
              style="display: none"
            >
              <label
                >Pattern:
                <select id="breathPattern">
                  <option value="box">Box 4-4-4-4</option>
                  <option value="478">4-7-8</option>
                  <option value="wimhof">Wim Hof</option>
                </select>
              </label>
            </div>
            <div class="control-group">
              <label>
                <input type="checkbox" id="affirmationMode" /> Affirmations
              </label>
            </div>
            <div class="control-group">
              <label>
                <input type="checkbox" id="eegFeedback" /> EEG Feedback
              </label>
            </div>
            <div class="control-group">
              <label>Group ID
                <input type="text" id="groupId" placeholder="optional" />
              </label>
              <button class="btn btn-secondary" id="joinGroupBtn">Join Group</button>
            </div>
          </div>
            <div class="composer-section">
              <h3>🎶 Session Composer <span class="help-icon" data-help="Create layered binaural tracks or run custom frequency programs">❔</span></h3>
              <p class="composer-desc">
                Layer additional frequencies to craft complex binaural mixes.
              </p>
              <div id="composerTracks"></div>
              <button class="btn btn-secondary" id="addTrack" data-help="Add another binaural layer">➕ Add Layer</button>
              <h4 style="margin-top:15px">Custom Frequency Program <span class="help-icon" data-help="Enter: duration base beat on each line (seconds & Hz)">❔</span></h4>
              <textarea id="freqProgram" rows="3" placeholder="duration base beat per line" data-help="Example: '60 110 4' will play 60s at 110Hz base with 4Hz beat"></textarea>
              <button class="btn btn-secondary" id="runProgram">▶ Run Program</button>
              <button class="btn btn-secondary" id="stopProgram">■ Stop</button>
            </div>

          <div class="session-controls">
            <button class="btn btn-primary" id="startBtn">
              🚀 Begin Session
            </button>
            <button class="btn btn-secondary" id="stopBtn">⏹️ Stop</button>
          </div>

          <div class="bookmark-section">
            <h3>🔖 Bookmarks</h3>
            <div class="bookmark-slots" id="bookmarkSlots">
              <button class="btn btn-secondary bookmark-btn" data-slot="1">
                Slot 1
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="2">
                Slot 2
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="3">
                Slot 3
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="4">
                Slot 4
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="5">
                Slot 5
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="6">
                Slot 6
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="7">
                Slot 7
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="8">
                Slot 8
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="9">
                Slot 9
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="10">
                Slot 10
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="11">
                Slot 11
              </button>
              <button class="btn btn-secondary bookmark-btn" data-slot="12">
                Slot 12
              </button>
            </div>
          </div>

          <div class="session-info" id="sessionInfo">
            <div>
              <span
                class="status-indicator status-offline"
                id="statusIndicator"
              ></span
              ><strong>Status:</strong> <span id="sessionStatus">Ready</span>
            </div>
            <div>
              <strong>Timer:</strong> <span id="sessionTimer">00:00</span>
            </div>
            <div>
              <strong>Current Focus:</strong>
              <span id="currentFocus">None Selected</span>
            </div>
            <div class="session-progress">
              <div class="progress-bar">
                <div class="progress-fill" id="sessionProgress"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="journal-section">
        <h3>📓 Session Journal & Insights</h3>
        <div class="journal-form">
          <div
            style="
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
            "
          >
            <div class="form-group">
              <label>Focus Level Used</label>
              <select id="journalFocus">
                <option value="">Select Focus Level</option>
                <option value="10">Focus 10 - Body Asleep</option>
                <option value="12">Focus 12 - Expanded</option>
                <option value="15">Focus 15 - No-Time</option>
                <option value="21">Focus 21 - Threshold</option>
                <option value="23+">Focus 23+ - Contact</option>
              </select>
            </div>
            <div class="form-group">
              <label>Mood Before (1-10)</label>
              <input
                type="number"
                id="moodBefore"
                min="1"
                max="10"
                placeholder="5"
              />
            </div>
            <div class="form-group">
              <label>Mood After (1-10)</label>
              <input
                type="number"
                id="moodAfter"
                min="1"
                max="10"
                placeholder="7"
              />
            </div>
          </div>
          <div class="form-group">
            <label>Session Reflection</label>
            <textarea
              id="reflection"
              placeholder="Describe your experience, any visions, sensations, insights, or contact experiences..."
            ></textarea>
          </div>
          <button class="btn btn-primary" id="saveJournal">
            💾 Save Entry
          </button>
        </div>

        <div class="stats-display">
          <div class="stat-card">
            <div class="stat-value" id="totalSessions">0</div>
            <div class="stat-label">Total Sessions</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="totalTime">0m</div>
            <div class="stat-label">Total Time</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="favoriteLevel">-</div>
            <div class="stat-label">Favorite Focus</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="contactEvents">0</div>
            <div class="stat-label">Contact Events</div>
          </div>
        </div>
        <button
          class="btn btn-secondary"
          id="analyzePatterns"
          style="margin-top: 15px"
        >
          🔍 Analyze Patterns
        </button>
        <button
          class="btn btn-secondary"
          id="exportData"
          style="margin-top: 15px"
        >
          ⬇️ Export Data
        </button>
        <label
          class="btn btn-secondary"
          for="importFile"
          style="margin-top: 15px"
          >⬆️ Import Data</label
        >
        <input
          type="file"
          id="importFile"
          accept="application/json"
          style="display: none"
        />
      </div>
      <div class="analysis-overlay" id="analysisOverlay">
        <div class="analysis-content">
          <button
            class="btn btn-secondary"
            id="closeAnalysis"
            style="float: right"
          >
            Close
          </button>
          <h3>📊 Pattern Analysis</h3>
          <div id="analysisResults"></div>
          <canvas id="analyticsChart" width="400" height="200"></canvas>
        </div>
      </div>
    </div>

    <script>
      class HemiLabGateway {
        constructor() {
          this.audioContext = null;
          this.engine = null;
          this.leftOscillator = null;
          this.rightOscillator = null;
          this.isochronicOscillator = null;
          this.deepBassOscillator = null;
          this.deepBassGain = null;
          this.deepBassFade = 0.05;
          this.phaseDelayNode = null;
          this.leftAnalyser = null;
          this.rightAnalyser = null;
          this.eqAnimation = null;
          this.gainNode = null;
          this.isPlaying = false;
          this.sessionStartTime = null;
          this.sessionTimer = null;
          this.currentFocusLevel = null;
          this.breathCycle = null;
          this.extraEngines = [];
          this.affirmations = [
            "You are calm and focused.",
            "Every breath deepens your awareness.",
            "Your mind is open and clear.",
            "Positive energy surrounds you.",
          ];
          this.targetDuration = 15 * 60;

          // EEG feedback
          this.eegSocket = null;
          this.eegEnabled = false;
          this.eegAdjust = {};
          this.groupId = null;
          this.programTimers = [];
          this.entropyInterval = null;

          this.focusPresets = {
            10: {
              baseFreq: 100,
              beatFreq: 7.5,
              description: "Body asleep, mind awake",
            },
            12: {
              baseFreq: 110,
              beatFreq: 9,
              description: "Expanded awareness state",
            },
            15: { baseFreq: 80, beatFreq: 1, description: "No-time zone" },
            21: { baseFreq: 90, beatFreq: 4, description: "Gateway threshold" },
            "23+": {
              baseFreq: 70,
              beatFreq: 2.5,
              description: "Contact/multidimensional states",
            },
          };

          this.initializeUI();
          this.loadUserData();
          this.initializeBookmarks();
        }

        async initializeAudio() {
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            this.gainNode = this.audioContext.createGain();
            this.gainNode.connect(this.audioContext.destination);
            this.engine = new BinauralEngine(this.audioContext, this.gainNode);
            this.initEqualizer();
          }

          if (this.audioContext.state === "suspended") {
            await this.audioContext.resume();
          }
        }

        initializeUI() {
          // Focus level selection
          document.querySelectorAll(".focus-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const level = e.target.dataset.focus;
              this.selectFocusLevel(level);
            });
          });

          document
            .getElementById("focusSlider")
            .addEventListener("input", (e) => {
              document.getElementById("focusSliderValue").textContent =
                e.target.value;
              const value = parseFloat(e.target.value);
              const levels = Object.keys(this.focusPresets).map((l) =>
                parseFloat(l),
              );
              const nearest = levels.reduce(
                (a, b) => (Math.abs(b - value) < Math.abs(a - value) ? b : a),
                levels[0],
              );
              this.selectFocusLevel(nearest.toString());
            });

          // Audio controls
          document.getElementById("baseFreq").addEventListener("input", (e) => {
            document.getElementById("baseFreqValue").textContent =
              e.target.value;
            if (this.isPlaying) this.updateFrequencies();
          });

          document.getElementById("beatFreq").addEventListener("input", (e) => {
            document.getElementById("beatFreqValue").textContent =
              e.target.value;
            if (this.isPlaying) this.updateFrequencies();
          });

          document
            .getElementById("waveType")
            .addEventListener("change", (e) => {
              if (this.engine) {
                this.engine.setWaveType(e.target.value);
              }
              if (this.isPlaying) {
                this.updateWaveType(e.target.value);
              }
            });

          document.getElementById("volume").addEventListener("input", (e) => {
            document.getElementById("volumeValue").textContent = e.target.value;
            if (this.gainNode && this.audioContext) {
              const now = this.audioContext.currentTime;
              if (this.gainNode.gain.setTargetAtTime) {
                this.gainNode.gain.setTargetAtTime(e.target.value / 100, now, 0.05);
              } else {
                this.gainNode.gain.value = e.target.value / 100;
              }
            }
          });

          document
            .getElementById("phaseShift")
            .addEventListener("input", (e) => {
              document.getElementById("phaseShiftValue").textContent =
                e.target.value;
              if (this.isPlaying) this.updatePhaseShift();
            });

          document
            .getElementById("sessionDuration")
            .addEventListener("input", (e) => {
              document.getElementById("durationValue").textContent =
                e.target.value;
              this.targetDuration = parseInt(e.target.value) * 60;
            });
          // Session controls
          document
            .getElementById("startBtn")
            .addEventListener("click", () => this.startSession());
          document
            .getElementById("stopBtn")
            .addEventListener("click", () => this.stopSession());

          // Breath coach toggle
          document
            .getElementById("breathCoachMode")
            .addEventListener("change", (e) => {
              document.getElementById("breathPatternGroup").style.display = e
                .target.checked
                ? "block"
                : "none";
              if (e.target.checked && this.isPlaying) {
                this.startBreathCoach();
              } else {
                this.stopBreathCoach();
              }
            });

          document
            .getElementById("addTrack")
            .addEventListener("click", () => this.addTrack());
          this.addTrack();

          // Affirmation toggle
          document
            .getElementById("affirmationMode")
            .addEventListener("change", (e) => {
              if (e.target.checked && this.isPlaying) {
                this.speakAffirmation();
              }
            });

          document
            .getElementById("rebalMode")
            .addEventListener("change", () => {
              this.animateREBAL();
            });

          document
            .getElementById("isochronicMode")
            .addEventListener("change", (e) => {
              if (this.isPlaying) {
                if (e.target.checked) {
                  this.startIsochronicPulse(
                    parseFloat(document.getElementById("beatFreq").value),
                    parseFloat(document.getElementById("volume").value) / 100,
                  );
                } else {
                  this.stopIsochronicPulse();
                }
              }
            });

            document
              .getElementById("driftMode")
              .addEventListener("change", (e) => {
                if (this.engine) {
                  if (e.target.checked) {
                    this.engine.startDrift();
                  } else {
                    this.engine.stopDrift();
                  }
                }
              });

          document
            .getElementById("deepBassMode")
            .addEventListener("change", (e) => {
              if (this.isPlaying) {
                if (e.target.checked) {
                  this.startDeepBass(
                    parseFloat(document.getElementById("volume").value) / 100,
                  );
                } else {
                  this.stopDeepBass();
                }
              }
            });

          const mode528 = document.getElementById("mode528");
          const mode528Slider = document.getElementById("mode528Slider");
          mode528.addEventListener("change", (e) => {
            if (e.target.checked) {
              document.getElementById("baseFreq").value = mode528Slider.value;
              document.getElementById("baseFreqValue").textContent =
                mode528Slider.value;
              if (this.isPlaying) this.updateFrequencies();
            }
          });
          mode528Slider.addEventListener("input", (e) => {
            document.getElementById("baseFreq").value = e.target.value;
            document.getElementById("baseFreqValue").textContent = e.target.value;
            if (mode528.checked && this.isPlaying) this.updateFrequencies();
          });

          // Journal saving
          document
            .getElementById("saveJournal")
            .addEventListener("click", () => this.saveJournalEntry());

          // Pattern analysis
          document
            .getElementById("analyzePatterns")
            .addEventListener("click", () => {
              const patterns = this.analyzeSessionPatterns();
              document.getElementById("analysisResults").innerHTML =
                this.formatPatternAnalysis(patterns);
              this.renderAnalyticsChart();
              document.getElementById("analysisOverlay").style.display = "flex";
            });
          document
            .getElementById("closeAnalysis")
            .addEventListener("click", () => {
              document.getElementById("analysisOverlay").style.display = "none";
            });
          document
            .getElementById("aiAnalyze")
            .addEventListener("click", () => this.analyzeJournalAI());

          // Data import/export
          document
            .getElementById("exportData")
            .addEventListener("click", () => this.exportData());
          document
            .getElementById("importFile")
            .addEventListener("change", (e) =>
              this.importData(e.target.files[0]),
            );

          // EEG feedback toggle
          document
            .getElementById("eegFeedback")
            .addEventListener("change", (e) => {
              if (e.target.checked) {
                this.connectEEG();
              } else {
                this.disconnectEEG();
              }
            });

          document
            .getElementById("joinGroupBtn")
            .addEventListener("click", () => this.joinGroup());

          document
            .getElementById("runProgram")
            .addEventListener("click", () => this.startFrequencyProgram());
          document
            .getElementById("stopProgram")
            .addEventListener("click", () => this.stopFrequencyProgram());

          document
            .getElementById("entropyMode")
            .addEventListener("change", (e) => {
              if (e.target.checked) {
                this.startEntropyDrift();
              } else {
                this.stopEntropyDrift();
              }
            });
        }

        connectEEG() {
          const url =
            location.origin && location.origin.startsWith("http")
              ? location.origin.replace(/^http/, "ws")
              : "ws://localhost:3000";
          this.eegSocket = new WebSocket(url);
          this.eegSocket.addEventListener("message", (e) =>
            this.handleEEGData(e.data),
          );
          this.eegSocket.addEventListener("open", () =>
            console.log("EEG socket connected"),
          );
          this.eegSocket.addEventListener("close", () =>
            console.log("EEG socket closed"),
          );
          this.eegEnabled = true;
        }

        disconnectEEG() {
          if (this.eegSocket) {
            this.eegSocket.close();
            this.eegSocket = null;
          }
          this.eegEnabled = false;
          this.eegAdjust = {};
        }

        joinGroup() {
          const id = document.getElementById("groupId").value.trim();
          if (!id) return;
          this.groupId = id;
          const msg = JSON.stringify({ type: "join", group: id });
          if (!this.eegSocket || this.eegSocket.readyState !== WebSocket.OPEN) {
            this.connectEEG();
            this.eegSocket.addEventListener(
              "open",
              () => this.eegSocket?.send(msg),
              { once: true },
            );
          } else {
            this.eegSocket.send(msg);
          }
        }

        handleEEGData(raw) {
          let data;
          try {
            data = JSON.parse(raw);
          } catch (e) {
            return;
          }

          let alpha = 0,
            beta = 0,
            theta = 0,
            delta = 0,
            count = 0;
          Object.values(data).forEach((ch) => {
            if (!ch) return;
            alpha += ch.alpha || 0;
            beta += ch.beta || 0;
            theta += ch.theta || 0;
            delta += ch.delta || 0;
            count++;
          });
          if (!count) return;
          alpha /= count;
          beta /= count;
          theta /= count;
          delta /= count;

          const alphaBeta = beta ? alpha / beta : 1;
          const thetaDelta = delta ? theta / delta : 1;

          this.eegAdjust = {
            baseOffset: (alphaBeta - 1) * 2,
            beatOffset: thetaDelta - 1,
            volume: Math.max(
              0,
              Math.min(
                1,
                0.5 + (alpha - beta) / (alpha + beta + theta + delta + 0.0001),
              ),
            ),
          };

          if (this.isPlaying) this.updateFrequencies();
        }

        selectFocusLevel(level) {
          document
            .querySelectorAll(".focus-btn")
            .forEach((btn) => btn.classList.remove("active"));
          document
            .querySelector(`[data-focus="${level}"]`)
            .classList.add("active");

          this.currentFocusLevel = level;
          document.getElementById("currentFocus").textContent =
            `Focus ${level}`;
          if (document.getElementById("focusSlider")) {
            document.getElementById("focusSlider").value =
              parseFloat(level) || parseFloat(level);
            document.getElementById("focusSliderValue").textContent = level;
          }

          if (this.focusPresets[level]) {
            const preset = this.focusPresets[level];
            document.getElementById("baseFreq").value = preset.baseFreq;
            document.getElementById("beatFreq").value = preset.beatFreq;
            document.getElementById("baseFreqValue").textContent =
              preset.baseFreq;
            document.getElementById("beatFreqValue").textContent =
              preset.beatFreq;

            if (this.isPlaying) this.updateFrequencies();
          }
        }

        async startSession() {
          try {
            await this.initializeAudio();
            const progressEl = document.getElementById("sessionProgress");
            if (progressEl) progressEl.style.width = "0%";

            const baseFreq = parseFloat(
              document.getElementById("baseFreq").value,
            );
            const beatFreq = parseFloat(
              document.getElementById("beatFreq").value,
            );
            const waveType = document.getElementById("waveType").value;
            const volume =
              parseFloat(document.getElementById("volume").value) / 100;
            const phaseShift = parseFloat(
              document.getElementById("phaseShift").value,
            );
            this.targetDuration =
              parseInt(document.getElementById("sessionDuration").value) * 60;

            const delaySeconds = phaseShift / 360 / baseFreq;

            // Create binaural beat
            this.leftOscillator = this.audioContext.createOscillator();
            this.rightOscillator = this.audioContext.createOscillator();
            this.leftOscillator.type = waveType;
            this.rightOscillator.type = waveType;

            this.phaseDelayNode = this.audioContext.createDelay(0.1);
            this.phaseDelayNode.delayTime.value = delaySeconds;

            const leftGain = this.audioContext.createGain();
            const rightGain = this.audioContext.createGain();
            const merger = this.audioContext.createChannelMerger(2);

            if (!this.leftAnalyser || !this.rightAnalyser) {
              this.initEqualizer();
            }

            this.leftOscillator.frequency.value = baseFreq;
            this.rightOscillator.frequency.value = baseFreq + beatFreq;

            this.leftOscillator.connect(leftGain);
            this.rightOscillator.connect(this.phaseDelayNode);
            this.phaseDelayNode.connect(rightGain);
            leftGain.connect(this.leftAnalyser);
            rightGain.connect(this.rightAnalyser);
            this.leftAnalyser.connect(merger, 0, 0);
            this.rightAnalyser.connect(merger, 0, 1);
            merger.connect(this.gainNode);

            leftGain.gain.value = volume * 0.5;
            rightGain.gain.value = volume * 0.5;

            const now = this.audioContext.currentTime;
            this.gainNode.gain.setValueAtTime(0, now);
            if (this.gainNode.gain.linearRampToValueAtTime) {
              this.gainNode.gain.linearRampToValueAtTime(volume, now + 0.1);
            } else {
              this.gainNode.gain.value = volume;
            }

            this.leftOscillator.start();
            this.rightOscillator.start();

            this.drawEqualizer();

            this.engine.leftOsc = this.leftOscillator;
            this.engine.rightOsc = this.rightOscillator;
            this.engine.setWaveType(waveType);
            this.engine.gainNode = this.gainNode;
            if (document.getElementById("driftMode").checked) {
              this.engine.startDrift();
            }

            // Start composed layers
            this.extraEngines.forEach((e) => e.stop());
            this.extraEngines = [];
            document.querySelectorAll("#composerTracks .track").forEach((t) => {
              const b = parseFloat(t.querySelector(".track-base").value);
              const beat = parseFloat(t.querySelector(".track-beat").value);
              const vol = parseFloat(t.querySelector(".track-vol").value) / 100;
              const eng = new BinauralEngine(
                this.audioContext,
                this.audioContext.createGain(),
              );
              eng.gainNode.connect(this.gainNode);
              eng.start(b, beat, vol, waveType);
              this.extraEngines.push(eng);
            });

            // Isochronic pulse if enabled
            if (document.getElementById("isochronicMode").checked) {
              this.startIsochronicPulse(beatFreq, volume);
            }

            // Deep bass layer if enabled
            if (document.getElementById("deepBassMode").checked) {
              this.startDeepBass(volume);
            }

            this.isPlaying = true;
            this.sessionStartTime = Date.now();
            this.updateSessionStatus("Active");
            this.startSessionTimer();

            if (document.getElementById("breathCoachMode").checked) {
              this.startBreathCoach();
            }

            if (document.getElementById("affirmationMode").checked) {
              this.speakAffirmation();
            }

            this.initializeContactMode();

            // Visual effects
            this.animateREBAL();

            document.getElementById("startBtn").textContent =
              "🔄 Session Active";
            document.getElementById("startBtn").disabled = true;
          } catch (error) {
            console.error("Error starting session:", error);
            alert(
              "Error starting audio session. Please check your browser permissions.",
            );
          }
        }

        startIsochronicPulse(frequency, volume) {
          if (this.engine) {
            this.engine.startIsochronic(frequency, volume * 0.2);
          }
        }

        stopIsochronicPulse() {
          if (this.engine) {
            this.engine.stopIsochronic();
          }
        }

        startDeepBass(volume, fadeDuration = this.deepBassFade) {
          const now = this.audioContext.currentTime;
          this.deepBassOscillator = this.audioContext.createOscillator();
          this.deepBassGain = this.audioContext.createGain();
          this.deepBassOscillator.type = "sine";
          this.deepBassOscillator.frequency.value = 60;
          this.deepBassOscillator.connect(this.deepBassGain);
          this.deepBassGain.connect(this.gainNode);
          this.deepBassGain.gain.setValueAtTime(0, now);
          if (this.deepBassGain.gain.linearRampToValueAtTime) {
            this.deepBassGain.gain.linearRampToValueAtTime(
              volume * 0.3,
              now + fadeDuration,
            );
          } else {
            this.deepBassGain.gain.value = volume * 0.3;
          }
          this.deepBassOscillator.start(now);
        }

        stopDeepBass(fadeDuration = this.deepBassFade) {
          if (this.deepBassOscillator && this.deepBassGain) {
            const now = this.audioContext.currentTime;
            this.deepBassGain.gain.cancelScheduledValues(now);
            this.deepBassGain.gain.setValueAtTime(
              this.deepBassGain.gain.value,
              now,
            );
            if (this.deepBassGain.gain.linearRampToValueAtTime) {
              this.deepBassGain.gain.linearRampToValueAtTime(0, now + fadeDuration);
            } else {
              this.deepBassGain.gain.value = 0;
            }
            this.deepBassOscillator.stop(now + fadeDuration);
            setTimeout(() => {
              if (this.deepBassOscillator) {
                this.deepBassOscillator.disconnect();
                this.deepBassOscillator = null;
              }
              if (this.deepBassGain) {
                this.deepBassGain.disconnect();
                this.deepBassGain = null;
              }
            }, fadeDuration * 1000);
          }
        }

        updateFrequencies() {
          if (!this.isPlaying) return;

          let baseFreq = parseFloat(document.getElementById("baseFreq").value);
          let beatFreq = parseFloat(document.getElementById("beatFreq").value);
          const phaseShift = parseFloat(
            document.getElementById("phaseShift").value,
          );

         if (this.eegEnabled && this.eegAdjust) {
            baseFreq += this.eegAdjust.baseOffset || 0;
            beatFreq += this.eegAdjust.beatOffset || 0;
            if (this.eegAdjust.volume != null && this.gainNode) {
              const now = this.audioContext.currentTime;
              if (this.gainNode.gain.setTargetAtTime) {
                this.gainNode.gain.setTargetAtTime(
                  this.eegAdjust.volume,
                  now,
                  0.05,
                );
              } else {
                this.gainNode.gain.value = this.eegAdjust.volume;
              }
              document.getElementById("volume").value = Math.round(
                this.eegAdjust.volume * 100,
              );
              document.getElementById("volumeValue").textContent = Math.round(
                this.eegAdjust.volume * 100,
              );
            }
          }

          const now = this.audioContext.currentTime;
          if (this.leftOscillator && this.rightOscillator) {
            if (this.leftOscillator.frequency.cancelScheduledValues) {
              this.leftOscillator.frequency.cancelScheduledValues(now);
            }
            if (this.leftOscillator.frequency.setTargetAtTime) {
              this.leftOscillator.frequency.setTargetAtTime(baseFreq, now, 0.1);
            } else {
              this.leftOscillator.frequency.value = baseFreq;
            }
            const target = baseFreq + beatFreq;
            if (this.rightOscillator.frequency.cancelScheduledValues) {
              this.rightOscillator.frequency.cancelScheduledValues(now);
            }
            if (this.rightOscillator.frequency.setTargetAtTime) {
              this.rightOscillator.frequency.setTargetAtTime(target, now, 0.1);
            } else {
              this.rightOscillator.frequency.value = target;
            }
          }

          if (this.isochronicOscillator) {
            if (this.isochronicOscillator.frequency.cancelScheduledValues) {
              this.isochronicOscillator.frequency.cancelScheduledValues(now);
            }
            if (this.isochronicOscillator.frequency.setTargetAtTime) {
              this.isochronicOscillator.frequency.setTargetAtTime(
                beatFreq,
                now,
                0.1,
              );
            } else {
              this.isochronicOscillator.frequency.value = beatFreq;
            }
          }

          if (this.phaseDelayNode) {
            const delay = phaseShift / 360 / baseFreq;
            if (this.phaseDelayNode.delayTime.cancelScheduledValues) {
              this.phaseDelayNode.delayTime.cancelScheduledValues(now);
            }
            if (this.phaseDelayNode.delayTime.setTargetAtTime) {
              this.phaseDelayNode.delayTime.setTargetAtTime(delay, now, 0.1);
            } else {
              this.phaseDelayNode.delayTime.value = delay;
            }
          }
        }

        updatePhaseShift() {
          if (!this.isPlaying || !this.phaseDelayNode) return;

          const baseFreq = parseFloat(
            document.getElementById("baseFreq").value,
          );
          const phaseShift = parseFloat(
            document.getElementById("phaseShift").value,
          );
          this.phaseDelayNode.delayTime.value = phaseShift / 360 / baseFreq;
        }

        updateWaveType(type) {
          if (this.leftOscillator) this.leftOscillator.type = type;
          if (this.rightOscillator) this.rightOscillator.type = type;
          this.extraEngines.forEach((e) => e.setWaveType(type));
        }

        stopSession() {
          const finalizeStop = () => {
            if (this.engine) {
              this.engine.stopDrift();
            }
            if (this.leftOscillator) {
              this.leftOscillator.stop();
              this.leftOscillator = null;
            }
            if (this.rightOscillator) {
              this.rightOscillator.stop();
              this.rightOscillator = null;
            }
            if (this.phaseDelayNode) {
              this.phaseDelayNode.disconnect();
              this.phaseDelayNode = null;
            }
            if (this.isochronicOscillator) {
              this.isochronicOscillator.stop();
              this.isochronicOscillator = null;
            }

            this.stopDeepBass();
            this.stopEqualizer();
            const l = document.getElementById("leftEQ");
            const r = document.getElementById("rightEQ");
            if (l) l.getContext("2d").clearRect(0, 0, l.width, l.height);
            if (r) r.getContext("2d").clearRect(0, 0, r.width, r.height);

            this.extraEngines.forEach((e) => e.stop());
            this.extraEngines = [];

            this.isPlaying = false;
            this.animateREBAL();
            this.updateSessionStatus("Complete");
            this.stopSessionTimer();
            this.stopBreathCoach();

            document.getElementById("startBtn").textContent = "🚀 Begin Session";
            document.getElementById("startBtn").disabled = false;

            // Auto-populate journal
            if (this.currentFocusLevel) {
              document.getElementById("journalFocus").value =
                this.currentFocusLevel;
            }
          };

          if (this.gainNode && this.audioContext) {
            const now = this.audioContext.currentTime;
            if (this.gainNode.gain.linearRampToValueAtTime) {
              this.gainNode.gain.cancelScheduledValues(now);
              this.gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
              setTimeout(finalizeStop, 120);
              return;
            }
            this.gainNode.gain.value = 0;
          }

          finalizeStop();
        }

        startSessionTimer() {
          const progressEl = document.getElementById("sessionProgress");
          progressEl.style.width = "0%";
          this.sessionTimer = setInterval(() => {
            const elapsed = Math.floor(
              (Date.now() - this.sessionStartTime) / 1000,
            );
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById("sessionTimer").textContent =
              `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
            if (this.targetDuration) {
              const pct = Math.min((elapsed / this.targetDuration) * 100, 100);
              progressEl.style.width = `${pct}%`;
            }
            if (this.targetDuration && elapsed >= this.targetDuration) {
              this.stopSession();
            }
          }, 1000);
        }

        stopSessionTimer() {
          if (this.sessionTimer) {
            clearInterval(this.sessionTimer);
            this.sessionTimer = null;
          }
          const progressEl = document.getElementById("sessionProgress");
          if (progressEl) progressEl.style.width = "0%";
        }

        startBreathCoach() {
          const breathCoach = document.getElementById("breathCoach");
          const breathText = document.getElementById("breathText");
          const breathProgress = document.getElementById("breathProgress");

          breathCoach.classList.add("active");

          let phase = 0; // 0: inhale, 1: hold, 2: exhale, 3: hold
          const pattern = document.getElementById("breathPattern").value;
          let durations, phases;
          if (pattern === "478") {
            durations = [4000, 7000, 8000, 0];
            phases = ["Breathe In", "Hold", "Breathe Out", ""];
          } else if (pattern === "wimhof") {
            durations = [2000, 2000, 2000, 2000];
            phases = ["In", "Hold", "Out", "Hold"];
          } else {
            durations = [4000, 4000, 4000, 4000];
            phases = ["Breathe In", "Hold", "Breathe Out", "Hold"];
          }

          const cycleBreath = () => {
            if (
              !document.getElementById("breathCoachMode").checked ||
              !this.isPlaying
            )
              return;

            breathText.textContent = phases[phase];
            breathProgress.style.transition = `width ${durations[phase]}ms linear`;
            breathProgress.style.width = "100%";

            setTimeout(() => {
              breathProgress.style.transition = "none";
              breathProgress.style.width = "0%";
              phase = (phase + 1) % 4;
              setTimeout(cycleBreath, 100);
            }, durations[phase]);
          };

          cycleBreath();
        }

        stopBreathCoach() {
          document.getElementById("breathCoach").classList.remove("active");
        }

        initEqualizer() {
          this.leftAnalyser = this.audioContext.createAnalyser();
          this.rightAnalyser = this.audioContext.createAnalyser();
          this.leftAnalyser.fftSize = 64;
          this.rightAnalyser.fftSize = 64;
        }

        drawEqualizer() {
          if (!this.leftAnalyser || !this.rightAnalyser) return;
          const leftCanvas = document.getElementById("leftEQ");
          const rightCanvas = document.getElementById("rightEQ");
          if (!leftCanvas || !rightCanvas) return;
          const lctx = leftCanvas.getContext("2d");
          const rctx = rightCanvas.getContext("2d");
          const len = this.leftAnalyser.frequencyBinCount;
          const ldata = new Uint8Array(len);
          const rdata = new Uint8Array(len);
          this.leftAnalyser.getByteFrequencyData(ldata);
          this.rightAnalyser.getByteFrequencyData(rdata);
          lctx.clearRect(0, 0, leftCanvas.width, leftCanvas.height);
          rctx.clearRect(0, 0, rightCanvas.width, rightCanvas.height);
          const lw = leftCanvas.width / len;
          const rw = rightCanvas.width / len;
          for (let i = 0; i < len; i++) {
            const lh = (ldata[i] / 255) * leftCanvas.height;
            const rh = (rdata[i] / 255) * rightCanvas.height;
            lctx.fillStyle = "#00ff88";
            lctx.fillRect(i * lw, leftCanvas.height - lh, lw - 1, lh);
            rctx.fillStyle = "#0099ff";
            rctx.fillRect(i * rw, rightCanvas.height - rh, rw - 1, rh);
          }
          this.eqAnimation = requestAnimationFrame(() => this.drawEqualizer());
        }

        stopEqualizer() {
          if (this.eqAnimation) {
            cancelAnimationFrame(this.eqAnimation);
            this.eqAnimation = null;
          }
        }

        startEntropyDrift() {
          this.stopEntropyDrift();
          this.entropyInterval = setInterval(() => {
            const base = parseFloat(document.getElementById("baseFreq").value);
            const beat = parseFloat(document.getElementById("beatFreq").value);
            const newBase = base + (Math.random() - 0.5) * 2;
            const newBeat = beat + (Math.random() - 0.5) * 0.5;
            document.getElementById("baseFreq").value = newBase.toFixed(2);
            document.getElementById("beatFreq").value = newBeat.toFixed(2);
            this.updateFrequencies();
          }, 5000);
        }

        stopEntropyDrift() {
          if (this.entropyInterval) {
            clearInterval(this.entropyInterval);
            this.entropyInterval = null;
          }
        }

        speakAffirmation() {
          if (!("speechSynthesis" in window)) return;
          const text =
            this.affirmations[
              Math.floor(Math.random() * this.affirmations.length)
            ];
          const utterance = new SpeechSynthesisUtterance(text);
          speechSynthesis.speak(utterance);
        }

        animateREBAL() {
          const orb = document.getElementById("rebalOrb");
          if (document.getElementById("rebalMode").checked && this.isPlaying) {
            orb.classList.add("animate");
          } else {
            orb.classList.remove("animate");
          }
        }

        updateSessionStatus(status) {
          document.getElementById("sessionStatus").textContent = status;
          const indicator = document.getElementById("statusIndicator");
          indicator.className =
            "status-indicator " +
            (status === "Active"
              ? "status-active"
              : status === "Contact"
                ? "status-contact"
                : "status-offline");
        }

        saveJournalEntry() {
          const entry = {
            timestamp: new Date().toISOString(),
            focusLevel: document.getElementById("journalFocus").value,
            moodBefore:
              parseInt(document.getElementById("moodBefore").value) || null,
            moodAfter:
              parseInt(document.getElementById("moodAfter").value) || null,
            reflection: document.getElementById("reflection").value,
            sessionDuration: this.getLastSessionDuration(),
          };

          if (!entry.focusLevel || !entry.reflection.trim()) {
            alert("Please select a focus level and add your reflection.");
            return;
          }

          let journals = JSON.parse(
            localStorage.getItem("hemilab_journals") || "[]",
          );
          journals.push(entry);
          localStorage.setItem("hemilab_journals", JSON.stringify(journals));

          // Update stats
          this.updateStats();

          // Clear form
          document.getElementById("journalFocus").value = "";
          document.getElementById("moodBefore").value = "";
          document.getElementById("moodAfter").value = "";
          document.getElementById("reflection").value = "";

          alert(
            "✨ Journal entry saved! Your consciousness journey is being tracked.",
          );

          // Check for contact event keywords
          this.analyzeForContactEvent(entry.reflection);
        }

        getLastSessionDuration() {
          if (this.sessionStartTime) {
            return Math.floor((Date.now() - this.sessionStartTime) / 1000);
          }
          return 0;
        }

        analyzeForContactEvent(reflection) {
          const contactKeywords = [
            "entity",
            "being",
            "presence",
            "voice",
            "message",
            "contact",
            "communication",
            "guide",
            "spirit",
            "other",
            "they",
            "spoke",
            "told",
            "showed",
            "revealed",
            "download",
            "transmission",
          ];

          const text = reflection.toLowerCase();
          const hasContactKeywords = contactKeywords.some((keyword) =>
            text.includes(keyword),
          );

          if (hasContactKeywords) {
            let userData = JSON.parse(
              localStorage.getItem("hemilab_userdata") || "{}",
            );
            userData.contactEvents = (userData.contactEvents || 0) + 1;
            localStorage.setItem("hemilab_userdata", JSON.stringify(userData));

            this.updateSessionStatus("Contact");
            setTimeout(() => {
              alert(
                "🛸 Contact event detected in your reflection! This has been logged for analysis.",
              );
            }, 500);
          }
        }

        loadUserData() {
          this.updateStats();
        }

        updateStats() {
          const journals = JSON.parse(
            localStorage.getItem("hemilab_journals") || "[]",
          );
          const userData = JSON.parse(
            localStorage.getItem("hemilab_userdata") || "{}",
          );

          // Total sessions
          document.getElementById("totalSessions").textContent =
            journals.length;

          // Total time
          const totalMinutes = journals.reduce((sum, entry) => {
            return sum + Math.floor((entry.sessionDuration || 0) / 60);
          }, 0);
          document.getElementById("totalTime").textContent = totalMinutes + "m";

          // Favorite focus level
          const focusCount = {};
          journals.forEach((entry) => {
            if (entry.focusLevel) {
              focusCount[entry.focusLevel] =
                (focusCount[entry.focusLevel] || 0) + 1;
            }
          });
          const favoriteLevel = Object.keys(focusCount).reduce(
            (a, b) => (focusCount[a] > focusCount[b] ? a : b),
            "-",
          );
          document.getElementById("favoriteLevel").textContent =
            favoriteLevel !== "-" ? `Focus ${favoriteLevel}` : "-";

          // Contact events
          document.getElementById("contactEvents").textContent =
            userData.contactEvents || 0;
        }

        exportData() {
          const data = localStorage.getItem("hemilab_journals") || "[]";
          const blob = new Blob([data], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "hemilab_journals.json";
          a.click();
          URL.revokeObjectURL(url);
        }

        importData(file) {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (Array.isArray(data)) {
                localStorage.setItem("hemilab_journals", JSON.stringify(data));
                this.updateStats();
                alert("📥 Journal data imported successfully!");
              } else {
                throw new Error("Invalid format");
              }
            } catch (err) {
              alert("Failed to import data: " + err.message);
            }
          };
          reader.readAsText(file);
        }

        addTrack() {
          const container = document.getElementById("composerTracks");
          const div = document.createElement("div");
          div.className = "track";
          div.innerHTML = `
                    <input type="number" class="track-base" placeholder="Base" value="150" min="40" max="1000">
                    <input type="number" class="track-beat" placeholder="Beat" value="4">
                    <input type="number" class="track-vol" placeholder="Vol" value="30">
                `;
          container.appendChild(div);

          const index = container.querySelectorAll(".track").length - 1;
          const baseInput = div.querySelector(".track-base");
          const beatInput = div.querySelector(".track-beat");
          const volInput = div.querySelector(".track-vol");

          const update = () => {
            const eng = this.extraEngines[index];
            if (eng) {
              eng.update(
                parseFloat(baseInput.value),
                parseFloat(beatInput.value),
              );
            }
          };
          const updateVol = () => {
            const eng = this.extraEngines[index];
            if (eng) {
              eng.setVolume(parseFloat(volInput.value) / 100);
            }
          };

          baseInput.addEventListener("input", update);
          beatInput.addEventListener("input", update);
          volInput.addEventListener("input", updateVol);

          if (this.isPlaying) {
            const eng = new BinauralEngine(
              this.audioContext,
              this.audioContext.createGain(),
            );
            eng.gainNode.connect(this.gainNode);
            eng.start(
              parseFloat(baseInput.value),
              parseFloat(beatInput.value),
              parseFloat(volInput.value) / 100,
              document.getElementById("waveType").value,
            );
            this.extraEngines.push(eng);
          }
        }

        startFrequencyProgram() {
          this.stopFrequencyProgram();
          const lines = document
            .getElementById("freqProgram")
            .value.split(/\n+/)
            .map((l) => l.trim())
            .filter(Boolean);
          let offset = 0;
          lines.forEach((line) => {
            const [dur, base, beat] = line.split(/\s+/).map(parseFloat);
            if (!dur || !base || !beat) return;
            const t = setTimeout(() => {
              document.getElementById("baseFreq").value = base;
              document.getElementById("beatFreq").value = beat;
              this.updateFrequencies();
            }, offset * 1000);
            this.programTimers.push(t);
            offset += dur;
          });
        }

        stopFrequencyProgram() {
          this.programTimers.forEach((t) => clearTimeout(t));
          this.programTimers = [];
        }

        bookmarkSettings(slot) {
          const settings = {
            baseFreq: document.getElementById("baseFreq").value,
            beatFreq: document.getElementById("beatFreq").value,
            waveType: document.getElementById("waveType").value,
            volume: document.getElementById("volume").value,
            phaseShift: document.getElementById("phaseShift").value,
            sessionDuration: document.getElementById("sessionDuration").value,
            mode528: document.getElementById("mode528").checked,
            mode528Freq: document.getElementById("mode528Slider").value,
            isochronicMode: document.getElementById("isochronicMode").checked,
            deepBassMode: document.getElementById("deepBassMode").checked,
            driftMode: document.getElementById("driftMode").checked,
            entropyMode: document.getElementById("entropyMode").checked,
            rebalMode: document.getElementById("rebalMode").checked,
            breathCoachMode: document.getElementById("breathCoachMode").checked,
            breathPattern: document.getElementById("breathPattern").value,
            affirmationMode: document.getElementById("affirmationMode").checked,
            eegFeedback: document.getElementById("eegFeedback").checked,
          };
        localStorage.setItem(
          `hemilab_bookmark_${slot}`,
          JSON.stringify(settings),
        );
        const btn = document.querySelector(`.bookmark-btn[data-slot="${slot}"]`);
        if (btn) btn.classList.add("active");
        alert(`🔖 Settings saved to Slot ${slot}!`);
      }

        initializeBookmarks() {
          document.querySelectorAll(".bookmark-btn").forEach((btn) => {
            const slot = btn.dataset.slot;
            if (localStorage.getItem(`hemilab_bookmark_${slot}`)) {
              btn.classList.add("active");
            }
            btn.addEventListener("click", () => {
              this.bookmarkSettings(slot);
            });
          });
        }

        analyzeJournalAI() {
          const text = document.getElementById("reflection").value;
          if (!text.trim()) {
            alert("Please add reflection text first.");
            return;
          }
          fetch("/api/analyze", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text }),
          })
            .then((r) => r.json())
            .then((d) => alert("🤖 " + d.summary))
            .catch(() => alert("AI analysis unavailable"));
        }

        // Advanced features for future phases
        initializeContactMode() {
          // Probability-based contact event triggers
          if (
            this.currentFocusLevel === "21" ||
            this.currentFocusLevel === "23+"
          ) {
            const contactProbability = Math.random();
            if (contactProbability > 0.85 && this.isPlaying) {
              setTimeout(
                () => {
                  this.triggerContactEvent();
                },
                Math.random() * 300000 + 600000,
              ); // 10-15 minutes into session
            }
          }
        }

        triggerContactEvent() {
          this.updateSessionStatus("Contact");

          // Subtle audio modification
          if (this.leftOscillator && this.rightOscillator) {
            const originalLeft = this.leftOscillator.frequency.value;
            const originalRight = this.rightOscillator.frequency.value;

            // Brief frequency shift
            this.leftOscillator.frequency.exponentialRampToValueAtTime(
              originalLeft * 0.98,
              this.audioContext.currentTime + 2,
            );
            this.rightOscillator.frequency.exponentialRampToValueAtTime(
              originalRight * 1.02,
              this.audioContext.currentTime + 2,
            );

            setTimeout(() => {
              if (this.leftOscillator && this.rightOscillator) {
                this.leftOscillator.frequency.exponentialRampToValueAtTime(
                  originalLeft,
                  this.audioContext.currentTime + 1,
                );
                this.rightOscillator.frequency.exponentialRampToValueAtTime(
                  originalRight,
                  this.audioContext.currentTime + 1,
                );
              }
            }, 3000);
          }

          // Visual contact indicator
          const orb = document.getElementById("rebalOrb");
          orb.style.boxShadow = `
                    0 0 100px rgba(255, 0, 136, 0.8),
                    inset 0 0 50px rgba(255, 255, 255, 0.3)
                `;

          setTimeout(() => {
            orb.style.boxShadow = `
                        0 0 50px rgba(0, 255, 136, 0.4),
                        inset 0 0 50px rgba(0, 153, 255, 0.2)
                    `;
          }, 5000);
        }

        // Pattern analysis for future implementation
        analyzeSessionPatterns() {
          const journals = JSON.parse(
            localStorage.getItem("hemilab_journals") || "[]",
          );

          // Analyze recurring themes, optimal times, mood patterns
          const patterns = {
            bestTimes: this.findOptimalSessionTimes(journals),
            moodCorrelations: this.analyzeMoodPatterns(journals),
            progressionPath: this.trackFocusProgression(journals),
          };

          return patterns;
        }

        findOptimalSessionTimes(journals) {
          // Analyze when user has best experiences
          const timeMap = {};
          journals.forEach((entry) => {
            const hour = new Date(entry.timestamp).getHours();
            const improvement =
              (entry.moodAfter || 5) - (entry.moodBefore || 5);
            timeMap[hour] = (timeMap[hour] || []).concat(improvement);
          });

          return Object.keys(timeMap)
            .map((hour) => ({
              hour: parseInt(hour),
              avgImprovement:
                timeMap[hour].reduce((a, b) => a + b, 0) / timeMap[hour].length,
            }))
            .sort((a, b) => b.avgImprovement - a.avgImprovement);
        }

        analyzeMoodPatterns(journals) {
          // Track mood improvement patterns by focus level
          const patterns = {};
          journals.forEach((entry) => {
            if (entry.moodBefore && entry.moodAfter && entry.focusLevel) {
              const level = entry.focusLevel;
              const improvement = entry.moodAfter - entry.moodBefore;
              patterns[level] = (patterns[level] || []).concat(improvement);
            }
          });

          return patterns;
        }

        trackFocusProgression(journals) {
          // See how user progresses through focus levels over time
          return journals.map((entry) => ({
            date: entry.timestamp,
            level: entry.focusLevel,
            quality: (entry.moodAfter || 5) - (entry.moodBefore || 5),
          }));
        }

        formatPatternAnalysis(patterns) {
          let html = "";

          html += "<h4>Optimal Session Times</h4>";
          if (patterns.bestTimes.length) {
            html +=
              "<ul>" +
              patterns.bestTimes
                .slice(0, 3)
                .map(
                  (p) =>
                    `<li>${p.hour}:00 \u2013 Avg Improvement ${p.avgImprovement.toFixed(2)}</li>`,
                )
                .join("") +
              "</ul>";
          } else {
            html += "<p>No data yet.</p>";
          }

          html += "<h4>Mood Improvement by Focus Level</h4>";
          const levels = Object.keys(patterns.moodCorrelations);
          if (levels.length) {
            html += "<ul>";
            levels.forEach((level) => {
              const arr = patterns.moodCorrelations[level];
              const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
              html += `<li>Focus ${level}: ${avg.toFixed(2)}</li>`;
            });
            html += "</ul>";
          } else {
            html += "<p>No data yet.</p>";
          }

          html += "<h4>Progression Path</h4>";
          if (patterns.progressionPath.length) {
            html +=
              "<ul>" +
              patterns.progressionPath
                .map(
                  (p) =>
                    `<li>${new Date(p.date).toLocaleDateString()}: Focus ${p.level} (${p.quality > 0 ? "+" : ""}${p.quality})</li>`,
                )
                .join("") +
              "</ul>";
          } else {
            html += "<p>No data yet.</p>";
          }

          return html;
        }

        renderAnalyticsChart() {
          const ctx = document
            .getElementById("analyticsChart")
            .getContext("2d");
          const journals = JSON.parse(
            localStorage.getItem("hemilab_journals") || "[]",
          );
          const counts = {};
          journals.forEach((j) => {
            if (j.focusLevel)
              counts[j.focusLevel] = (counts[j.focusLevel] || 0) + 1;
          });
          new Chart(ctx, {
            type: "bar",
            data: {
              labels: Object.keys(counts),
              datasets: [
                {
                  label: "Sessions",
                  data: Object.values(counts),
                  backgroundColor: "#0099ff",
                },
              ],
            },
            options: {
              responsive: false,
              scales: { y: { beginAtZero: true } },
            },
          });
        }
      }

      function attachHelpTooltip(el, text) {
        const tip = document.createElement("div");
        tip.className = "help-tooltip";
        tip.textContent = text;
        document.body.appendChild(tip);
        el.addEventListener("mouseenter", () => {
          const r = el.getBoundingClientRect();
          tip.style.left = `${r.left + window.pageXOffset}px`;
          tip.style.top = `${r.bottom + 8 + window.pageYOffset}px`;
          tip.style.display = "block";
        });
        el.addEventListener("mouseleave", () => {
          tip.style.display = "none";
        });
      }

      function initHelpTooltips() {
        document
          .querySelectorAll("[data-help]")
          .forEach((el) => attachHelpTooltip(el, el.dataset.help));
      }

      // Initialize the application
      let app;

      // Create app instance on DOM ready
      document.addEventListener("DOMContentLoaded", () => {
        app = new HemiLabGateway();
        initHelpTooltips();
        const themeToggle = document.getElementById("themeToggle");
          const storedTheme = localStorage.getItem("hemilab_theme") || "dark";
          if (storedTheme === "light") {
            document.body.classList.add("light-mode");
            themeToggle.checked = true;
          }
          themeToggle.addEventListener("change", () => {
            if (themeToggle.checked) {
              document.body.classList.add("light-mode");
              localStorage.setItem("hemilab_theme", "light");
            } else {
              document.body.classList.remove("light-mode");
              localStorage.setItem("hemilab_theme", "dark");
            }
          });
      
        // Add some initial guidance
        const welcomeMessage = `
🧠 Welcome to Hemi-Lab Gateway Terminal

Your consciousness exploration platform is ready. Features available:

✅ Binaural Beat Engine - Create custom frequency entrainment
✅ Focus Level Navigator - Monroe Institute inspired states  
✅ REBAL Energy Shield - Resonant protection visualization
✅ Breath Coach - Synchronized breathing guidance
✅ Session Journal - Track your journey and insights
✅ Pattern Analysis - Discover your optimal practice times
✅ Affirmation Layer - Spoken positive cues

🚀 Select a Focus Level and click "Begin Session" to start your exploration.

For best results:
• Use quality headphones
• Find a quiet, comfortable space  
• Set an intention before beginning
• Journal your experiences after each session

The deeper states (Focus 15, 21, 23+) may produce profound experiences. Trust the process and document everything.

Safe travels, consciousness explorer. ✨
            `;

        console.log(welcomeMessage);
      });

      // Activate audio context on first user interaction
      document.addEventListener(
        "click",
        () => {
          if (app) {
            app.initializeAudio();
          }
        },
        { once: true },
      );

      // Add some keyboard shortcuts for advanced users
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case " ":
              e.preventDefault();
              if (app && app.isPlaying) {
                app.stopSession();
              } else if (app) {
                app.startSession();
              }
              break;
            case "j":
              e.preventDefault();
              document.getElementById("reflection").focus();
              break;
          }
        }
      });

      // Easter egg for advanced users
      let konamiCode = [];
      const konamiSequence = [
        "ArrowUp",
        "ArrowUp",
        "ArrowDown",
        "ArrowDown",
        "ArrowLeft",
        "ArrowRight",
        "ArrowLeft",
        "ArrowRight",
        "KeyB",
        "KeyA",
      ];

      document.addEventListener("keydown", (e) => {
        konamiCode.push(e.code);
        if (konamiCode.length > 10) konamiCode.shift();

        if (JSON.stringify(konamiCode) === JSON.stringify(konamiSequence)) {
          alert(
            '🛸 Advanced Contact Protocols Unlocked\n\nHidden frequencies now available in Focus 27+\nQuantum entanglement mode enabled\nRemote viewing assistance activated\n\n"The Explorer becomes the Explored" - TMI',
          );
          konamiCode = [];
        }
      });
    </script>
  </body>
</html>
